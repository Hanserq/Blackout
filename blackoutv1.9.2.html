<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Blackout — Encrypt / Decrypt</title>

<!-- Guard: only allow if unlocked in last 30 minutes -->
<script>
(function(){
  const MAX_AGE = 30*60*1000;
  const ts = Number(sessionStorage.getItem('blackout.unlockedAt') || 0);
  const hasLock = !!localStorage.getItem('blackout.lock.hash');
  if (hasLock && (!ts || Date.now()-ts > MAX_AGE)) location.replace('index.html');
})();
</script>

<style>
  :root{
    --bg:#0a0b0f; --fg:#e9ebf2; --muted:#a6acc3; --accent:#8ba7ff; --ok:#35d69b; --err:#ff6b6b;
    --card:#121420; --stroke:#23263a; --hover:#1a1d2c; --radius:18px;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:1080px;margin:28px auto;padding:0 18px}
  h1{margin:0 0 8px;font-size:clamp(24px,3.6vw,36px);letter-spacing:-.02em}
  .sub{color:var(--muted);margin:0 0 18px;font-size:clamp(13px,1.9vw,15px)}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:18px}
  .card{background:var(--card);border:1px solid var(--stroke);border-radius:var(--radius);padding:16px;box-shadow:0 10px 28px rgba(0,0,0,.35)}
  .card h3{margin:0 0 10px;font-size:18px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
  .row3{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:10px}
  label{display:block;font-size:12px;color:var(--muted);margin:6px 0 6px}
  input,select,button{font:inherit}
  input[type="text"],input[type="password"],select{
    width:100%;padding:12px;border-radius:14px;border:1px solid var(--stroke);background:#0e1020;color:var(--fg)
  }
  input::placeholder{color:#8086a4}
  button{background:var(--accent);color:#0b0f1c;border:0;padding:12px 16px;border-radius:14px;font-weight:800;cursor:pointer}
  button.secondary{background:#222842;color:var(--fg)}
  button:active{transform:translateY(1px)}
  .actions{margin-top:10px;display:flex;gap:10px;flex-wrap:wrap}
  .drop{border:1.5px dashed #2d3350;border-radius:16px;padding:18px;text-align:center;color:var(--muted);min-height:120px;display:grid;place-items:center;cursor:pointer}
  .drop.active{outline:2px dashed var(--accent)}
  .log{white-space:pre-wrap;font-size:13px;line-height:1.45;background:#0d1122;border-radius:14px;padding:10px;border:1px solid #1d2135;min-height:54px}
  .ok{color:var(--ok)} .err{color:var(--err)} .hint{font-size:12px;color:var(--muted);margin-top:6px}
  :is(input,select,button):focus{outline:none;box-shadow:0 0 0 3px rgba(139,167,255,.25)}
  /* Mobile */
  @media (max-width: 900px){
    .grid{grid-template-columns:1fr}
    .row,.row3{grid-template-columns:1fr}
    .drop{min-height:150px}
    button, input[type="text"],input[type="password"],select{font-size:16px}
  }

  /* Accessible hidden input (Safari-friendly) */
  .sr-only{
    position:absolute;width:1px;height:1px;padding:0;margin:-1px;
    overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0
  }

  /* Compact dashed pill for cover picker */
  .cover-picker{
    display:inline-flex;align-items:center;gap:10px;
    border:1.5px dashed #2d3350;border-radius:12px;
    padding:10px 12px;background:#0e1020;cursor:pointer;user-select:none
  }
  .cover-picker .upload-text{font-size:.9rem;color:var(--muted)}
  .cover-picker.active{outline:2px dashed var(--accent)}
</style>
</head>
<body>
<div class="wrap">
  <h1>Blackout v2</h1>
  <p class="sub">Encrypt any file into a PNG (optional cover image) and decrypt it back — fully offline.</p>

  <div class="grid">
    <!-- ENCRYPT -->
    <section class="card" id="enc-card">
      <h3>Encrypt → PNG</h3>

      <!-- Drop area as label (best for iOS/Safari) -->
      <label class="drop" id="enc-drop" for="enc-file">
        <div><strong id="enc-drop-label">Drop file here</strong><br/>or choose…</div>
      </label>
      <input id="enc-file" type="file" class="sr-only" />

      <div class="row3">
        <div>
          <label>Passphrase</label>
          <input id="enc-pass" type="password" placeholder="Strong passphrase" autocomplete="new-password">
        </div>
        <div>
          <label>KDF</label>
          <select id="kdf-select">
            <option value="pbkdf2_std" selected>PBKDF2 — Standard</option>
            <option value="pbkdf2_strong">PBKDF2 — Strong</option>
          </select>
        </div>
        <div>
          <label>Output PNG name</label>
          <input id="enc-png-name" type="text" placeholder="e.g., blackout_1234">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Stored filename (restored on decrypt)</label>
          <input id="enc-stored-name" type="text" placeholder="e.g., secret.pdf">
        </div>

        <div>
          <label class="form-label">Cover Image (Optional)</label>
          <!-- compact cover picker -->
          <label id="coverPicker" class="cover-picker" for="coverImage" role="button" aria-label="Choose cover image">
            <span class="upload-text">Choose cover image</span>
          </label>
          <input id="coverImage" type="file" accept="image/*" class="sr-only">
          <small class="hint">If set, the output looks like this image (still saved as PNG).</small>
        </div>
      </div>

      <div class="actions">
        <button id="btn-enc">Encrypt</button>
        <button id="btn-clear-enc" class="secondary">Clear</button>
      </div>
      <div id="enc-log" class="log" style="margin-top:10px">Ready.</div>
    </section>

    <!-- DECRYPT -->
    <section class="card" id="dec-card">
      <h3>Decrypt ← PNG</h3>

      <label class="drop" id="dec-drop" for="dec-file">
        <div><strong id="dec-drop-label">Drop PNG here</strong><br/>or choose…</div>
      </label>
      <input id="dec-file" type="file" accept="image/png" class="sr-only" />

      <label style="margin-top:10px">Passphrase</label>
      <input id="dec-pass" type="password" placeholder="Your passphrase" autocomplete="current-password">

      <div class="actions">
        <button id="btn-dec">Decrypt</button>
        <button id="btn-clear-dec" class="secondary">Clear</button>
      </div>
      <div id="dec-log" class="log" style="margin-top:10px">Ready.</div>
    </section>
  </div>
</div>

<script>
/* ---------- small helpers ---------- */
const $ = (id) => document.getElementById(id);
const TE = new TextEncoder(), TD = new TextDecoder();
function log(el, msg, cls=''){ el.className = 'log ' + (cls||''); el.textContent = msg; }
function concatBytes(...arrs){ let len=arrs.reduce((a,b)=>a+b.length,0),out=new Uint8Array(len),off=0; for(const a of arrs){ out.set(a,off); off+=a.length; } return out; }
function be64(n){ const out=new Uint8Array(8); for(let i=7;i>=0;i--){ out[i]=Number(n&0xffn); n>>=8n; } return out; }
function readBE64(u8,off){ let n=0n; for(let i=0;i<8;i++) n=(n<<8n)|BigInt(u8[off+i]); return n; }
function randomBytes(n){ const out=new Uint8Array(n); let o=0; while(o<n){ const len=Math.min(n-o,65536); const chunk=new Uint8Array(len); crypto.getRandomValues(chunk); out.set(chunk,o); o+=len; } return out; }
function safeFilename(name){ name=(name||'').normalize ? name.normalize('NFC') : (name||''); name=name.replace(/[\\/:*?"<>|]/g,'_').replace(/[\u0000-\u001F\u007F-\u009F]/g,'_').trim(); if(!name) name='file'; if(name.length>200) name=name.slice(0,200); return name; }
function splitNameExt(name){ const i=(name||'').lastIndexOf('.'); return (i>0 && i<name.length-1)?{base:name.slice(0,i),ext:name.slice(i)}:{base:name||'file',ext:''}; }
function sanitizeExt(ext){ return (/^\.[A-Za-z0-9]{1,10}$/).test(ext||'') ? ext : ''; }

/* ---------- KDFs ---------- */
async function kdf_pbkdf2(pass,salt,iters){
  const keyMaterial = await crypto.subtle.importKey('raw', TE.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:iters}, keyMaterial, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']);
}
async function deriveKey(pass,salt,mode){
  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const iters = mode==='pbkdf2_strong' ? (isMobile?400000:1000000) : 250000;
  return kdf_pbkdf2(pass,salt,iters);
}

/* ---------- PNG helpers ---------- */
async function imageFileToPngBytes(file){
  if (file && file.type === 'image/png') return new Uint8Array(await file.arrayBuffer());
  const bmp = ('createImageBitmap' in window)
    ? await createImageBitmap(file)
    : await new Promise((res, rej) => {
        const img = new Image(); img.onload = ()=>res(img); img.onerror = rej;
        img.src = URL.createObjectURL(file);
      });
  const w=bmp.width, h=bmp.height;
  let canvas; if (typeof OffscreenCanvas !== 'undefined') { canvas = new OffscreenCanvas(w,h); }
  else { canvas = Object.assign(document.createElement('canvas'), {width:w,height:h}); }
  const ctx = canvas.getContext('2d'); ctx.drawImage(bmp,0,0);
  const blob = canvas.convertToBlob ? await canvas.convertToBlob({type:'image/png'})
                                    : await new Promise(r => canvas.toBlob(r,'image/png'));
  return new Uint8Array(await blob.arrayBuffer());
}

async function makeBlackPNG(){
  const size = 128;
  let canvas; if (typeof OffscreenCanvas !== 'undefined') { canvas = new OffscreenCanvas(size,size); }
  else { canvas = Object.assign(document.createElement('canvas'), {width:size,height:size}); }
  const ctx = canvas.getContext('2d'); ctx.fillStyle='#000'; ctx.fillRect(0,0,size,size);
  const blob = canvas.convertToBlob ? await canvas.convertToBlob({type:'image/png'})
                                    : await new Promise(r=>canvas.toBlob(r,'image/png'));
  return new Uint8Array(await blob.arrayBuffer());
}

/* ---------- core: container ---------- */
async function encryptBlob(file, pass, storedName, kdfMode, coverPngBytes){
  const MAX_BYTES = 100 * 1024 * 1024;
  if (file.size > MAX_BYTES) throw new Error('File exceeds 100 MB cap.');
  const fileBytes = new Uint8Array(await file.arrayBuffer());
  const pick = (storedName && storedName.trim()) ? storedName.trim() : (file.name || 'file.bin');
  const parts = splitNameExt(pick);
  const meta = {
    filename: safeFilename(parts.base),
    ext: sanitizeExt(parts.ext) || sanitizeExt(splitNameExt(file.name||'').ext) || '',
    mime: file.type || 'application/octet-stream',
    size: fileBytes.length
  };
  const metaJson = TE.encode(JSON.stringify(meta));
  const metaLen  = new Uint8Array(4); new DataView(metaLen.buffer).setUint32(0, metaJson.length, false);
  let plain = concatBytes(metaLen, metaJson, fileBytes);
  const block = 256*1024, padLen = (block - (plain.length % block)) % block;
  if (padLen) plain = concatBytes(plain, randomBytes(padLen));
  const salt = randomBytes(16), nonce = randomBytes(12);
  const key = await deriveKey(pass, salt, kdfMode);
  const ct  = new Uint8Array(await crypto.subtle.encrypt({name:'AES-GCM', iv:nonce}, key, plain));
  const marker = randomBytes(16);
  const body   = concatBytes(marker, salt, nonce, ct);
  const len    = be64(BigInt(body.length));
  const trailer= concatBytes(len, marker);
  const png = (coverPngBytes && coverPngBytes.length) ? coverPngBytes : await makeBlackPNG();
  const out = concatBytes(png, body, trailer);
  return new Blob([out], {type:'image/png'});
}

async function decryptPNG(pngFile, pass){
  const bytes = new Uint8Array(await pngFile.arrayBuffer());
  if (bytes.length < 24) throw new Error('Too small');
  const len = readBE64(bytes, bytes.length - 24);
  const bodyEndBig = BigInt(bytes.length - 24);
  if (len <= 0n || len > bodyEndBig) throw new Error('Invalid container length');
  const bodyStart = Number(bodyEndBig - len), bodyEnd = Number(bodyEndBig);
  const body = bytes.slice(bodyStart, bodyEnd);
  const markerFooter = bytes.slice(bytes.length - 16);
  for (let i=0;i<16;i++) if (body[i] !== markerFooter[i]) throw new Error('Not a Blackout container (marker).');
  const salt  = body.slice(16, 32);
  const nonce = body.slice(32, 44);
  const ct    = body.slice(44);
  for (const mode of ['pbkdf2_strong', 'pbkdf2_std']){
    try{
      const key = await deriveKey(pass, salt, mode);
      const plain = new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM', iv:nonce}, key, ct));
      const metaLen = new DataView(plain.buffer, plain.byteOffset, plain.byteLength).getUint32(0, false);
      const meta = JSON.parse(TD.decode(plain.slice(4, 4+metaLen)));
      const fileBytes = plain.slice(4+metaLen, 4+metaLen + (meta.size||0));
      let outName = 'restored.bin';
      if (meta && typeof meta === 'object') {
        if (meta.filename && meta.ext !== undefined) {
          outName = safeFilename(meta.filename) + (sanitizeExt(meta.ext) || '');
        } else if (meta.filename) {
          outName = safeFilename(meta.filename);
        }
      }
      return { meta, fileBytes, outName, mime: meta.mime || 'application/octet-stream' };
    }catch(_){ /* try next */ }
  }
  throw new Error('Wrong passphrase or different KDF.');
}

/* ---------- filename/KDF/cover helpers (privacy-safe) ---------- */
(function(){
  function pick(){ for(const s of arguments){ const el=document.querySelector(s); if(el) return el; } return null; }
  const outNameEl = pick('#enc-png-name','input[name="outputName"]');
  const kdfSel    = pick('#kdf-select','select[name="kdf"]');
  const coverEl   = document.getElementById('coverImage');

  function genOutputName(ext='png'){
    const a = Math.random().toString(36).slice(2,8);
    const b = Math.random().toString(36).slice(2,6);
    return `blackout_${a}_${b}.${ext}`;
  }
  function normalizeOutName(raw, ext='png'){
    let s = (raw||'').trim().replace(/[/\\:*?"<>|]/g, '-');
    if (!s) return genOutputName(ext);
    s = s.replace(/^[.\s]+/,'');
    const wanted = ext.toLowerCase();
    if (s.toLowerCase().endsWith('.blackout')) return s;
    if (!s.toLowerCase().endsWith('.'+wanted)) s += '.'+wanted;
    return s;
  }

  window.computeSafeOutputName = function(userProvidedName, forceExt){
    const ext = (forceExt || 'png').toLowerCase();
    if (!userProvidedName) return genOutputName(ext);
    return normalizeOutName(userProvidedName, ext);
  };

  window.getSelectedKdfLabel = function(){
    if (kdfSel){
      const opt = kdfSel.options[kdfSel.selectedIndex];
      return (opt && (opt.textContent||opt.innerText||'')).trim() || 'PBKDF2 — Standard';
    }
    return 'PBKDF2 — Standard';
  };

  window.isCoverUsed = function(){
    try { return !!(coverEl && coverEl.files && coverEl.files.length); } catch { return false; }
  };
})();
</script>

<!-- ---------- UI wiring + Drag & Drop ---------- -->
<script>
(function(){
  const encFile=$('enc-file'), encPass=$('enc-pass'), encLog=$('enc-log'), btnEnc=$('btn-enc'), btnClearEnc=$('btn-clear-enc');
  const decFile=$('dec-file'), decPass=$('dec-pass'), decLog=$('dec-log'), btnDec=$('btn-dec'), btnClearDec=$('btn-clear-dec');
  const encStoredName=$('enc-stored-name'), encPNGName=$('enc-png-name'), kdfSelect=$('kdf-select');
  const encCover=document.getElementById('coverImage');
  const encDrop=$('enc-drop'), decDrop=$('dec-drop');
  const encDropLabel=$('enc-drop-label'), decDropLabel=$('dec-drop-label');

  // Prevent page navigation on drop
  ['dragover','drop'].forEach(t=>{
    addEventListener(t, e=>e.preventDefault(), true);
    document.addEventListener(t, e=>e.preventDefault(), true);
  });

  function wireDrop(zone, input, labelEl, acceptFn){
    zone.addEventListener('dragover', e=>{ e.preventDefault(); zone.classList.add('active'); });
    zone.addEventListener('dragleave', ()=> zone.classList.remove('active'));
    zone.addEventListener('drop', e=>{
      e.preventDefault(); zone.classList.remove('active');
      const files = Array.from(e.dataTransfer.files || []);
      const picked = acceptFn ? files.find(acceptFn) : files[0];
      if (!picked) return;
      let dt; try { dt = new DataTransfer(); } catch { dt = new ClipboardEvent('').clipboardData || null; }
      if (dt) { dt.items.add(picked); input.files = dt.files; }
      input.dispatchEvent(new Event('change', {bubbles:true}));
      if (labelEl) labelEl.textContent = picked.name;
    });
  }
  wireDrop(encDrop, encFile, encDropLabel, () => true);
  wireDrop(decDrop, decFile, decDropLabel, f => /image\/png$/i.test(f.type));

  encFile.addEventListener('change', () => {
    if (encFile.files.length) {
      encDropLabel.textContent = encFile.files[0].name;
      log(encLog, `Picked: ${encFile.files[0].name}`);
    }
  });
  decFile.addEventListener('change', () => {
    if (decFile.files.length) {
      decDropLabel.textContent = decFile.files[0].name;
      log(decLog, `Picked PNG: ${decFile.files[0].name}`);
    }
  });

  btnClearEnc.onclick = ()=>{ encFile.value=''; encPass.value=''; encStoredName.value=''; encPNGName.value=''; encCover.value=''; log(encLog,'Cleared.'); encDropLabel.textContent='Drop file here'; };
  btnClearDec.onclick = ()=>{ decFile.value=''; decPass.value=''; log(decLog,'Cleared.'); decDropLabel.textContent='Drop PNG here'; };

  btnEnc.onclick = async ()=>{
    const f=encFile.files[0], p=encPass.value, mode=kdfSelect.value;
    if(!f) return log(encLog,'Pick a file.','err');
    if(!p || p.length<6) return log(encLog,'Use a stronger passphrase (6+).','err');
    btnEnc.disabled=true; log(encLog,'Encrypting…');
    try{
      let coverBytes=null;
      if (encCover && encCover.files && encCover.files[0]) {
        log(encLog,'Encrypting…\nPreparing cover image…');
        coverBytes = await imageFileToPngBytes(encCover.files[0]);
      }
      const blob = await encryptBlob(f, p, encStoredName.value, mode, coverBytes);

      // --- PRIVACY-SAFE OUTPUT NAME ---
      const outName = window.computeSafeOutputName(($('enc-png-name')?.value || '').trim(), 'png');

      // Download
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=outName;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href),8000);

      // Status: show only the output name (no original leak)
      log(encLog,'Done → '+outName,'ok');

      // Accurate Vault log (only if user has an active/unlocked vault)
      const kdfLabel = window.getSelectedKdfLabel();
      const notes = window.isCoverUsed() ? 'Cover used' : '';
      window.blackoutLogEncryption?.({
        originalName: f?.name || '(unknown)',
        outputName: outName,
        size: f?.size || 0,
        kdf: kdfLabel,
        notes
      });
    }catch(e){ log(encLog, e?.message || String(e), 'err'); }
    finally{ btnEnc.disabled=false; }
  };

  btnDec.onclick = async ()=>{
    const f=decFile.files[0], p=decPass.value;
    if(!f) return log(decLog,'Pick a PNG.','err');
    if(!p) return log(decLog,'Enter passphrase.','err');
    btnDec.disabled=true; log(decLog,'Decrypting…');
    try{
      const {meta,fileBytes,outName,mime} = await decryptPNG(f,p);
      const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([fileBytes],{type:mime})); a.download=outName; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href),8000);
      log(decLog,`Recovered “${a.download}” (${meta.size} bytes).`,'ok');
    }catch(e){ log(decLog, e?.message || String(e), 'err'); }
    finally{ btnDec.disabled=false; }
  };
})();
</script>

<!-- Cover picker label/drag -->
<script>
const coverInput  = document.getElementById('coverImage');
const coverPicker = document.getElementById('coverPicker');
if (coverInput && coverPicker) {
  const coverText = coverPicker.querySelector('.upload-text');
  coverInput.addEventListener('change', () => {
    const f = coverInput.files && coverInput.files[0];
    coverText.textContent = f ? f.name : 'Choose cover image';
  });
  ['dragover','drop'].forEach(ev =>
    coverPicker.addEventListener(ev, e => e.preventDefault())
  );
  coverPicker.addEventListener('dragover', () => coverPicker.classList.add('active'));
  coverPicker.addEventListener('dragleave', () => coverPicker.classList.remove('active'));
  coverPicker.addEventListener('drop', e => {
    coverPicker.classList.remove('active');
    const files = e.dataTransfer && e.dataTransfer.files;
    const f = files && files[0];
    if (!f) return;
    let dt;
    try { dt = new DataTransfer(); } catch { dt = new ClipboardEvent('').clipboardData || null; }
    if (dt) { dt.items.add(f); coverInput.files = dt.files; }
    else { coverText.textContent = f.name; return; }
    coverInput.dispatchEvent(new Event('change', { bubbles: true }));
  });
}
</script>

<!-- === Tutorial styles & Help button (unchanged) === -->
<style>
  .help-fab{
    position:fixed; top:14px; right:14px; z-index:9998;
    background:#222842; color:#e9ebf2; border:1px solid #2f3350; border-radius:999px;
    padding:8px 12px; font-weight:700; cursor:pointer; box-shadow:0 8px 24px rgba(0,0,0,.35)
  }
  .help-fab:focus{outline:none; box-shadow:0 0 0 3px rgba(139,167,255,.35)}
  .tut-overlay{
    position:fixed; inset:0; display:none; place-items:center; padding:18px;
    background:rgba(8,10,20,.65); backdrop-filter:saturate(110%) blur(6px);
    z-index:10000;
  }
  .tut-overlay[aria-hidden="false"]{ display:grid; }
  .tut-card{
    width:min(720px,94vw); background:#121420; color:#e9ebf2;
    border:1px solid #23263a; border-radius:18px; box-shadow:0 16px 48px rgba(0,0,0,.45);
  }
  .tut-head{ display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid #23263a }
  .tut-title{ font-size:18px; font-weight:800; letter-spacing:-.01em }
  .tut-x{ background:transparent; border:0; color:#a6acc3; cursor:pointer; font-size:20px; line-height:1 }
  .tut-body{ padding:16px; display:grid; gap:12px }
  .tut-slide h3{ margin:.2rem 0 .4rem; font-size:20px }
  .tut-slide p, .tut-slide ul{ margin:.2rem 0; color:#a6acc3; font-size:14px; line-height:1.5 }
  .tut-slide ul{ padding-left:18px }
  .tut-foot{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; border-top:1px solid #23263a }
  .tut-btn{ background:#8ba7ff; color:#0b0f1c; border:0; padding:10px 14px; border-radius:12px; font-weight:800; cursor:pointer }
  .tut-btn.secondary{ background:#222842; color:#e9ebf2 }
  .tut-dots{ display:flex; gap:6px }
  .tut-dot{ width:8px; height:8px; border-radius:50%; background:#2d3350 }
  .tut-dot.active{ background:#8ba7ff }
</style>

<button id="helpBtn" class="help-fab" aria-haspopup="dialog" aria-controls="tutorialModal" title="Help / Tutorial">Help</button>

<div id="tutorialModal" class="tut-overlay" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="tut-card" role="document">
    <div class="tut-head">
      <div class="tut-title">Blackout — Quick Tour</div>
      <button class="tut-x" id="tutClose" aria-label="Close tutorial">×</button>
    </div>
    <div class="tut-body">
      <section class="tut-slide" data-slide="0">
        <h3>What Blackout does</h3>
        <p>Turn <strong>any file</strong> into a PNG that looks like a normal image, or export a safer
        <code>.blackout</code> container. Decrypt to get the original file back — fully offline.</p>
        <ul>
          <li>Encryption: AES-256-GCM with PBKDF2-SHA-256 (client-side WebCrypto).</li>
          <li>Optional cover image to “camouflage” your PNG.</li>
          <li>Best for sharing: <code>.blackout</code> (no image compression risk).</li>
        </ul>
      </section>
      <section class="tut-slide" data-slide="1" hidden>
        <h3>Encrypt → PNG</h3>
        <ul>
          <li>Drop a file in the left card (or choose).</li>
          <li>Enter a strong passphrase and pick KDF strength.</li>
          <li>Optionally set a “Stored filename” and a cover image.</li>
          <li>Click <strong>Encrypt</strong> → download your PNG.</li>
        </ul>
      </section>
      <section class="tut-slide" data-slide="2" hidden>
        <h3>Decrypt ← PNG</h3>
        <ul>
          <li>Drop the PNG in the right card.</li>
          <li>Enter the same passphrase you used to encrypt.</li>
          <li>Click <strong>Decrypt</strong> → your original file is restored.</li>
        </ul>
      </section>
      <section class="tut-slide" data-slide="3" hidden>
        <h3>Sharing & Tips</h3>
        <ul>
          <li>Don’t send PNGs through apps that compress images — it corrupts data.</li>
          <li>Prefer sending <strong>.blackout</strong> (or ZIP) as a <strong>Document</strong>.</li>
          <li>App Lock is for UX gating; encryption protects your files.</li>
        </ul>
      </section>
    </div>
    <div class="tut-foot">
      <button id="tutSkip" class="tut-btn secondary">Skip</button>
      <div class="tut-dots" aria-hidden="true">
        <span class="tut-dot" data-dot="0"></span>
        <span class="tut-dot" data-dot="1"></span>
        <span class="tut-dot" data-dot="2"></span>
        <span class="tut-dot" data-dot="3"></span>
      </div>
      <div style="display:flex; gap:8px">
        <button id="tutPrev" class="tut-btn secondary" disabled>Back</button>
        <button id="tutNext" class="tut-btn">Next</button>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const LS_KEY = 'blackout.tutorialSeen';
  const modal = document.getElementById('tutorialModal');
  const helpBtn = document.getElementById('helpBtn');
  const btnNext = document.getElementById('tutNext');
  const btnPrev = document.getElementById('tutPrev');
  const btnSkip = document.getElementById('tutSkip');
  const btnClose= document.getElementById('tutClose');
  const slides = [...modal.querySelectorAll('.tut-slide')];
  const dots   = [...modal.querySelectorAll('.tut-dot')];
  let i = 0, lastFocus = null;

  function setDot(n){ dots.forEach((d,idx)=>d.classList.toggle('active', idx===n)); }
  function showSlide(n){
    i = Math.max(0, Math.min(slides.length-1, n));
    slides.forEach((s,idx)=> s.hidden = idx !== i);
    setDot(i);
    btnPrev.disabled = (i===0);
    btnNext.textContent = (i===slides.length-1) ? 'Done' : 'Next';
  }
  function openTutorial(initial=false){
    lastFocus = document.activeElement;
    modal.setAttribute('aria-hidden','false');
    showSlide(initial ? 0 : i);
    (modal.querySelector('.tut-x') || modal).focus({preventScroll:true});
    trapFocus(true);
  }
  function closeTutorial(markSeen=true){
    modal.setAttribute('aria-hidden','true');
    trapFocus(false);
    if (markSeen) localStorage.setItem(LS_KEY, '1');
    lastFocus && lastFocus.focus({preventScroll:true});
  }

  function trapFocus(enable){
    function loop(e){
      if (!enable || modal.getAttribute('aria-hidden')==='true') return;
      const f = modal.querySelectorAll('button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])');
      const ff = Array.from(f).filter(el=>!el.hasAttribute('disabled'));
      if (!ff.length) return;
      const first = ff[0], last = ff[ff.length-1];
      if (e.key === 'Tab'){
        if (e.shiftKey && document.activeElement === first){ last.focus(); e.preventDefault(); }
        else if (!e.shiftKey && document.activeElement === last){ first.focus(); e.preventDefault(); }
      }
      if (e.key === 'Escape'){ closeTutorial(false); }
      if (e.key === 'ArrowRight'){ btnNext.click(); }
      if (e.key === 'ArrowLeft'){ if(!btnPrev.disabled) btnPrev.click(); }
    }
    (enable ? document.addEventListener : document.removeEventListener)('keydown', loop);
  }

  btnNext.addEventListener('click', ()=>{ if (i < slides.length-1) showSlide(i+1); else closeTutorial(true); });
  btnPrev.addEventListener('click', ()=> showSlide(i-1));
  btnSkip.addEventListener('click', ()=> closeTutorial(true));
  btnClose.addEventListener('click', ()=> closeTutorial(false));
  helpBtn.addEventListener('click', ()=> openTutorial(false));

  if (!localStorage.getItem(LS_KEY)) setTimeout(()=>openTutorial(true), 250);
  setDot(0);
})();
</script>

<!-- ===================== Vaults Card (full width, aligned to 1080px) ===================== -->
<style>
  .vaults-card{
    width:min(1080px, 94vw);           /* aligned with main wrap */
    margin:24px auto 60px;
    background:#121420; color:#e9ebf2;
    border:1px solid #23263a; border-radius:18px;
    box-shadow:0 16px 48px rgba(0,0,0,.45);
  }
  .vaults-head{ display:flex; align-items:center; justify-content:space-between; padding:16px 18px; border-bottom:1px solid #23263a }
  .vaults-title{ font-size:20px; font-weight:800; letter-spacing:-.01em }
  .vaults-body{ padding:14px 18px; display:grid; gap:16px }

  .vaults-actions{ display:flex; gap:10px; flex-wrap:wrap }
  .vbtn{ background:#222842; color:#e9ebf2; border:1px solid #2f3350; border-radius:12px; padding:10px 14px; font-weight:700; cursor:pointer }
  .vbtn.primary{ background:#8ba7ff; color:#0b0f1c; border-color:#8ba7ff }
  .vinput{
    width:100%; max-width:360px; padding:10px 12px; border-radius:10px;
    border:1px solid #2d3350; background:#0b0f1c; color:#e9ebf2
  }
  .vlist{ display:grid; gap:10px }
  .vrow{
    border:1px solid #23263a; border-radius:12px; padding:10px 12px;
    background:#0f1320;
  }
  .vrow-head{ display:grid; grid-template-columns: 1fr auto auto auto auto; gap:12px; align-items:center }
  .vname{ font-weight:800 }
  .vmeta{ color:#a6acc3; font-size:12px }
  .vrow-actions{ display:flex; gap:8px; justify-content:flex-end }
  .vcollapse{ background:#222842; border:0; color:#e9ebf2; border-radius:10px; padding:6px 10px; cursor:pointer }
  .vrow-body{ margin-top:10px; display:none }
  .vrow[aria-expanded="true"] .vrow-body{ display:block }

  .vtable-wrap{ overflow:auto; max-height:40vh; border:1px solid #23263a; border-radius:12px; padding:8px; }
  .vtable{ width:100%; border-collapse:separate; border-spacing:0 6px; font-size:14px }
  .vtable th{ text-align:left; color:#a6acc3; font-weight:600 }
  .vtable td{ vertical-align:top }
  .hint{ color:#a6acc3; font-size:12px }
  .warn{ color:#f39c9c; font-size:12px }
</style>

<section class="vaults-card" id="vaultsCard" aria-label="Vaults">
  <div class="vaults-head">
    <div class="vaults-title">Vaults</div>
    <div class="vaults-actions">
      <input id="newVaultName" class="vinput" placeholder="New vault name (e.g., Personal)" />
      <button id="createVaultBtn" class="vbtn primary" title="Create empty vault; unlock with App Lock passcode">Create new</button>
    </div>
  </div>

  <div class="vaults-body">
    <div id="vaultsNotice" class="hint">
      No vault unlocked. Create one or unlock an existing vault to start auto-logging encrypts.
    </div>
    <div id="vaultsList" class="vlist"></div>
  </div>
</section>

<script>
/* ================================================================
   Multi-Vault System (encrypted at rest, unlocked with App Lock passcode)
   Storage layout:
     - Index:   localStorage['blackout.vaults.index.v1'] = [{id,name,created,updated,count}]
     - Vault N: localStorage['blackout.vault.v1::<id>'] = {v:1, iv, salt, data, ts}
   Encryption:
     - AES-256-GCM; per-vault random salt; PBKDF2-SHA-256 (150k) using the App-Lock passcode.
   Active vault:
     - sessionStorage['blackout.activeVaultId'] (in-memory across tab lifetime)
================================================================ */
(function(){
  const IDX_KEY = 'blackout.vaults.index.v1';
  const VAULT_PREFIX = 'blackout.vault.v1::';
  const ACTIVE_KEY = 'blackout.activeVaultId';

  const enc = new TextEncoder(), dec = new TextDecoder();
  const $ = sel => document.querySelector(sel);
  const listEl = $('#vaultsList');
  const noticeEl = $('#vaultsNotice');

  // In-memory unlocked state
  const unlocked = new Map(); // id -> {key:CryptoKey, data:Array}

  // ---------- helpers ----------
  function b64e(buf){ return btoa(String.fromCharCode(...new Uint8Array(buf))); }
  function b64d(s){ return Uint8Array.from(atob(s), c=>c.charCodeAt(0)); }
  function now(){ return Date.now(); }
  function fmt(n){
    const u=['B','KB','MB','GB']; let i=0; while(n>=1024&&i<u.length-1){n/=1024;i++;}
    return (n<10&&i? n.toFixed(1): Math.round(n))+' '+u[i];
  }

  function readIndex(){
    try{ return JSON.parse(localStorage.getItem(IDX_KEY)||'[]'); }catch{ return []; }
  }
  function writeIndex(arr){ localStorage.setItem(IDX_KEY, JSON.stringify(arr)); }

  function readVaultRaw(id){
    try{ const s = localStorage.getItem(VAULT_PREFIX+id); return s? JSON.parse(s): null; }catch{ return null; }
  }
  function writeVaultRaw(id, obj){
    localStorage.setItem(VAULT_PREFIX+id, JSON.stringify(obj));
  }

  async function deriveKey(pass, salt, iters=150000){
    const base = await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']);
    return crypto.subtle.deriveKey({name:'PBKDF2', salt, iterations: iters, hash:'SHA-256'},
                                   base, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);
  }

  async function encryptArr(key, arr){
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, enc.encode(JSON.stringify(arr)));
    return {iv: b64e(iv), data: b64e(ct), ts: now()};
  }
  async function decryptArr(key, ivB64, dataB64){
    const iv=b64d(ivB64), data=b64d(dataB64);
    const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, data);
    return JSON.parse(dec.decode(pt));
  }

  function uid(){ return Math.random().toString(36).slice(2)+Date.now().toString(36); }

  // ---------- UI render ----------
  function render(){
    const idx = readIndex().sort((a,b)=> (b.updated||b.created) - (a.updated||a.created));
    listEl.innerHTML = '';
    if (!idx.length){
      listEl.innerHTML = `<div class="hint">No vaults yet. Create your first vault above.</div>`;
      return;
    }

    const activeId = sessionStorage.getItem(ACTIVE_KEY);
    noticeEl.textContent = unlocked.size ? `Active vault: ${activeId ? (idx.find(v=>v.id===activeId)?.name||'Unknown') : '—'}` :
                                           'No vault unlocked. Create or unlock to start auto-logging.';

    for(const v of idx){
      const row = document.createElement('div');
      row.className = 'vrow';
      row.setAttribute('data-id', v.id);
      row.setAttribute('aria-expanded', 'false');
      const isUnlocked = unlocked.has(v.id);
      const count = v.count || 0;
      const updated = new Date(v.updated||v.created).toLocaleString();

      row.innerHTML = `
        <div class="vrow-head">
          <div>
            <div class="vname">${escapeHtml(v.name)}</div>
            <div class="vmeta">Created ${new Date(v.created).toLocaleString()} • Updated ${updated} • ${count} item${count===1?'':'s'}</div>
          </div>
          <div class="vmeta ${isUnlocked?'':'warn'}" style="justify-self:end">${isUnlocked ? 'Unlocked' : 'Locked'}</div>
          <div class="vrow-actions">
            ${isUnlocked
              ? `<button class="vbtn" data-act="lock">Lock</button>
                 <button class="vbtn" data-act="export">Export CSV</button>
                 <button class="vbtn" data-act="clear">Clear</button>`
              : `<input type="password" class="vinput" data-act="pass" placeholder="App Lock passcode" style="max-width:220px">
                 <button class="vbtn primary" data-act="unlock">Unlock</button>`
            }
            <button class="vbtn" data-act="rename">Rename</button>
            <button class="vbtn" data-act="delete">Delete</button>
            <button class="vcollapse" data-act="toggle">${isUnlocked?'Collapse':'Expand'}</button>
          </div>
        </div>
        <div class="vrow-body">
          ${isUnlocked ? tableHtml(v.id, unlocked.get(v.id).data) : `<div class="hint">Unlock to view entries.</div>`}
        </div>
      `;
      attachRowHandlers(row, v);
      listEl.appendChild(row);
    }
  }

  function tableHtml(id, arr){
    const rows = [...arr].sort((a,b)=>(b.when||0)-(a.when||0));
    const tr = rows.map(r=>`
      <tr>
        <td>${new Date(r.when||Date.now()).toLocaleString()}</td>
        <td>${escapeHtml(r.originalName||'-')}</td>
        <td style="text-align:right">${fmt(r.size||0)}</td>
        <td>${escapeHtml(r.outputName||'-')}</td>
        <td>${escapeHtml(r.kdf||'-')}</td>
        <td>${escapeHtml(r.notes||'')}</td>
      </tr>`).join('');
    return `
      <div style="display:flex; gap:8px; justify-content:flex-end; margin:6px 0 8px">
        <button class="vbtn" data-act="make-active" title="Use this as default target for auto-log">Set Active</button>
        <button class="vbtn" data-act="add-test">Add test</button>
      </div>
      <div class="vtable-wrap">
        <table class="vtable">
          <thead>
            <tr><th>When</th><th>Original name</th><th style="text-align:right">Size</th><th>Output</th><th>KDF</th><th>Notes</th></tr>
          </thead>
          <tbody>${tr||''}</tbody>
        </table>
      </div>
      ${rows.length? '' : `<div class="hint" style="margin-top:6px">No entries yet. Encrypt something — it will appear here if this vault is active.</div>`}
    `;
  }

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

  // ---------- row actions ----------
  function attachRowHandlers(row, meta){
    row.addEventListener('click', async (e)=>{
      const act = e.target?.getAttribute?.('data-act');
      if (!act) return;
      const id = meta.id;

      if (act==='toggle'){
        const ex = row.getAttribute('aria-expanded')==='true';
        row.setAttribute('aria-expanded', String(!ex));
        if (!ex && unlocked.has(id)){
          row.querySelector('.vrow-body').innerHTML = tableHtml(id, unlocked.get(id).data);
        }
      }

      if (act==='unlock'){
        const pass = row.querySelector('[data-act="pass"]').value || '';
        const raw = readVaultRaw(id);
        if (!raw || !raw.salt){ alert('Vault is missing or corrupt.'); return; }
        try{
          const key = await deriveKey(pass, b64d(raw.salt));
          const data = raw.iv && raw.data ? await decryptArr(key, raw.iv, raw.data) : [];
          unlocked.set(id, {key, data});
          sessionStorage.setItem(ACTIVE_KEY, id);
          row.setAttribute('aria-expanded','true');
          render();
        }catch(err){
          alert('Incorrect passcode or corrupt vault.');
        }
      }

      if (act==='lock'){
        unlocked.delete(id);
        if (sessionStorage.getItem(ACTIVE_KEY)===id) sessionStorage.removeItem(ACTIVE_KEY);
        render();
      }

      if (act==='export'){
        const d = unlocked.get(id)?.data || [];
        if (!d.length){ alert('Nothing to export.'); return; }
        const header=['when_iso','original_name','size_bytes','output_name','kdf','notes'];
        const rows = d.map(r=>[
          new Date(r.when||Date.now()).toISOString(),
          r.originalName||'', r.size||0, r.outputName||'', r.kdf||'', (r.notes||'').replace(/\n/g,' ')
        ]);
        const csv = [header.join(','), ...rows.map(r=>r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(','))].join('\n');
        const blob = new Blob([csv], {type:'text/csv'});
        const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`vault_${id}.csv`; a.click(); URL.revokeObjectURL(a.href);
      }

      if (act==='clear'){
        if (!confirm('Clear all entries in this vault?')) return;
        const rec = unlocked.get(id); if (!rec) return alert('Unlock first.');
        rec.data = []; await persist(id, rec); render();
      }

      if (act==='delete'){
        if (!confirm(`Delete vault “${meta.name}”? This cannot be undone.`)) return;
        localStorage.removeItem(VAULT_PREFIX+id);
        writeIndex(readIndex().filter(x=>x.id!==id));
        unlocked.delete(id);
        if (sessionStorage.getItem(ACTIVE_KEY)===id) sessionStorage.removeItem(ACTIVE_KEY);
        render();
      }

      if (act==='rename'){
        const name = prompt('New name:', meta.name);
        if (!name) return;
        const idx = readIndex(); const v = idx.find(x=>x.id===id); if (!v) return;
        v.name = name; v.updated = now(); writeIndex(idx); render();
      }

      if (act==='make-active'){
        if (!unlocked.has(id)){ alert('Unlock this vault first.'); return; }
        sessionStorage.setItem(ACTIVE_KEY, id);
        noticeEl.textContent = `Active vault: ${meta.name}`;
      }

      if (act==='add-test'){
        await addEntry(id, {
          originalName:'secret.pdf', outputName:'blackout_demo.png',
          size: 1234567, kdf:'PBKDF2 — Standard', notes:'Cover used', when: now()
        });
        render();
      }
    });
  }

  // ---------- create / persist ----------
  $('#createVaultBtn').addEventListener('click', async ()=>{
    const name = ($('#newVaultName').value || 'Vault '+new Date().toLocaleDateString()).trim();
    if (!name) return;
    const pass = prompt('Enter your App Lock passcode to create this vault:') || '';
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const key = await deriveKey(pass, salt);
    const id = uid(); const created = now();
    const empty = await encryptArr(key, []);
    writeVaultRaw(id, {v:1, iv: empty.iv, data: empty.data, salt: b64e(salt), ts: created});
    const idx = readIndex(); idx.push({id, name, created, updated: created, count:0}); writeIndex(idx);
    unlocked.set(id, {key, data:[]}); sessionStorage.setItem(ACTIVE_KEY, id);
    $('#newVaultName').value = '';
    render();
  });

  async function persist(id, rec){
    const raw = readVaultRaw(id); if (!raw) return;
    const encd = await encryptArr(rec.key, rec.data);
    writeVaultRaw(id, {v:1, iv: encd.iv, data: encd.data, salt: raw.salt, ts: now()});
    const idx = readIndex(); const meta = idx.find(x=>x.id===id);
    if (meta){ meta.updated = now(); meta.count = rec.data.length; writeIndex(idx); }
  }

  async function addEntry(id, entry){
    const rec = unlocked.get(id);
    if (!rec){ alert('Unlock a vault first (or set one as active).'); return; }
    rec.data.push(Object.assign({when: now(), notes:''}, entry||{}));
    await persist(id, rec);
  }

  // ---------- public “auto-log” API ----------
  window.blackoutLogEncryption = async function(entry){
    try{
      const active = sessionStorage.getItem(ACTIVE_KEY);
      if (!active || !unlocked.has(active)){
        noticeEl.classList.add('warn');
        noticeEl.textContent = 'No active vault unlocked. Unlock a vault and click “Set Active” to enable auto-logging.';
        return;
      }
      await addEntry(active, entry);
      noticeEl.classList.remove('warn');
      noticeEl.textContent = 'Logged to active vault.';
      render();
    }catch(e){ console.error('[Vaults] log failed', e); }
  };

  render();
})();
</script>

</body>
</html>
