<!--- blackoutv1.9.2.html (with Argon2id + Vaults + Help + Particles) --->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Blackout — Encrypt / Decrypt</title>

<!-- Security headers -->
<meta http-equiv="Content-Security-Policy"
      content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' 'wasm-unsafe-eval' 'unsafe-eval';
        style-src 'self' 'unsafe-inline';
        img-src 'self' blob: data:;
        worker-src 'self' blob:;
        connect-src 'self';
        object-src 'none';
        base-uri 'none';
        frame-ancestors 'none';
      ">

<!-- Guard: only allow if unlocked in last 30 minutes -->
<script>(function(){const MAX_AGE=30*60*1000;const ts=Number(sessionStorage.getItem('blackout.unlockedAt')||0);const hasLock=!!localStorage.getItem('blackout.lock.hash');if(hasLock&&(!ts||Date.now()-ts>MAX_AGE)) location.replace('index.html');})();</script>

<style>
  :root{ --bg:#0a0b0f; --fg:#e9ebf2; --muted:#a6acc3; --accent:#8ba7ff; --ok:#35d69b; --err:#ff6b6b;
         --card:#121420; --stroke:#23263a; --hover:#1a1d2c; --radius:18px; }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  /* Ensure content stacks over background */
  body { position: relative; z-index: 0; }
  .wrap{max-width:1080px;margin:28px auto;padding:0 18px; position:relative; z-index: 2;}
  h1{margin:0 0 8px;font-size:clamp(24px,3.6vw,36px);letter-spacing:-.02em}
  .sub{color:var(--muted);margin:0 0 18px;font-size:clamp(13px,1.9vw,15px)}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:18px}
  .card{background:var(--card);border:1px solid var(--stroke);border-radius:var(--radius);padding:16px;box-shadow:0 10px 28px rgba(0,0,0,.35)}

  /* Transparent cards only when particles are enabled */
  body.particles-on .card{
  background: rgba(18,20,32,0.65);      /* ~35% see-through */
  border-color: rgba(35,38,58,0.40);    /* soften the stroke */
  backdrop-filter: blur(6px);           /* optional glassy feel */
  }
  /* (optional) Soften a few inner surfaces too */
  body.particles-on .log{ background: rgba(13,17,34,0.65); }
  body.particles-on .drop{ background: rgba(14,16,32,0.40); }

  .card h3{margin:0 0 10px;font-size:18px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
  .row3{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:10px}
  label{display:block;font-size:12px;color:var(--muted);margin:6px 0 6px}
  input,select,button{font:inherit}
  input[type="text"],input[type="password"],select{width:100%;padding:12px;border-radius:14px;border:1px solid var(--stroke);background:#0e1020;color:var(--fg)}
  input::placeholder{color:#8086a4}
  button{background:var(--accent);color:#0b0f1c;border:0;padding:12px 16px;border-radius:14px;font-weight:800;cursor:pointer}
  button.secondary{background:#222842;color:var(--fg)}
  button:active{transform:translateY(1px)}
  .actions{margin-top:10px;display:flex;gap:10px;flex-wrap:wrap}
  .drop{border:1.5px dashed #2d3350;border-radius:16px;padding:18px;text-align:center;color:var(--muted);min-height:120px;display:grid;place-items:center;cursor:pointer}
  .drop.active{outline:2px dashed var(--accent)}
  .log{white-space:pre-wrap;font-size:13px;line-height:1.45;background:#0d1122;border-radius:14px;padding:10px;border:1px solid #1d2135;min-height:54px}
  .ok{color:var(--ok)} .err{color:var(--err)} .hint{font-size:12px;color:var(--muted);margin-top:6px}
  @media (max-width: 900px){ .grid{grid-template-columns:1fr} .row,.row3{grid-template-columns:1fr} .drop{min-height:150px} button, input[type="text"],input[type="password"],select{font-size:16px} }
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  .cover-picker{display:inline-flex;align-items:center;gap:10px;border:1.5px dashed #2d3350;border-radius:12px;padding:10px 12px;background:#0e1020;cursor:pointer;user-select:none}
  .cover-picker .upload-text{font-size:.9rem;color:var(--muted)} .cover-picker.active{outline:2px dashed var(--accent)}

  /* Help button */
  .help-btn{position:fixed;top:14px;right:16px;z-index:60;background:#222842;border:1px solid #2f3350;
    color:#e9ebf2;border-radius:14px;padding:10px 14px;font-weight:700;cursor:pointer}
  .help-btn:hover{background:#2a2f4a}

  /* Particles toggle (near Help) */
  .particles-toggle{position:fixed;top:14px;right:120px;z-index:60;background:#222842;border:1px solid #2f3350;
    color:#e9ebf2;border-radius:14px;padding:10px 14px;font-weight:700;cursor:pointer}
  .particles-toggle:hover{background:#2a2f4a}

  /* Help modal */
  .help-overlay{position:fixed;inset:0;z-index:80;background:rgba(0,0,0,.6);backdrop-filter:blur(4px);display:none}
  .help-overlay[aria-hidden="false"]{display:grid;place-items:center}
  .help-card{width:min(720px,92vw);background:#121420;border:1px solid #23263a;border-radius:18px;
    box-shadow:0 18px 60px rgba(0,0,0,.55);padding:16px 16px 12px}
  .help-head{display:flex;align-items:center;justify-content:space-between;padding:6px 6px 10px}
  .help-title{font-weight:800;font-size:18px}
  .help-body{min-height:220px}
  .help-slide{display:none}
  .help-slide.active{display:block}
  .help-actions{display:flex;justify-content:space-between;gap:10px;margin-top:12px}
  .help-actions .left, .help-actions .right{display:flex;gap:8px}
  .hbtn{background:#222842;color:#e9ebf2;border:1px solid #2f3350;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer}
  .hbtn.primary{background:#8ba7ff;border-color:#8ba7ff;color:#0b0f1c}
  .dots{display:flex;gap:6px;align-items:center;justify-content:center;margin-top:8px}
  .dot{width:8px;height:8px;border-radius:999px;background:#2a2f4a}
  .dot.active{background:#8ba7ff}
  .help-body p{margin:0 0 8px;color:#cdd2ea}
  .help-body ul{margin:8px 0 0 18px;color:#cdd2ea}

  /* Vaults */
  .vaults-card{width:min(1080px,94vw);margin:24px auto 60px;background:#121420;color:#e9ebf2;border:1px solid #23263a;border-radius:18px;box-shadow:0 16px 48px rgba(0,0,0,.45);}
  .vaults-head{display:flex;align-items:center;justify-content:space-between;padding:16px 18px;border-bottom:1px solid #23263a}
  .vaults-title{font-size:20px;font-weight:800;letter-spacing:-.01em}
  .vaults-body{padding:14px 18px;display:grid;gap:16px}
  .vaults-actions{display:flex;gap:10px;flex-wrap:wrap}
  .vbtn{background:#222842;color:#e9ebf2;border:1px solid #2f3350;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer}
  .vbtn.primary{background:#8ba7ff;color:#0b0f1c;border-color:#8ba7ff}
  .vinput{width:100%;max-width:360px;padding:10px 12px;border-radius:10px;border:1px solid #2d3350;background:#0b0f1c;color:#e9ebf2}
  .vlist{display:grid;gap:10px}
  .vrow{border:1px solid #23263a;border-radius:12px;padding:10px 12px;background:#0f1320}
  .vrow-head{display:grid;grid-template-columns:1fr auto auto auto auto;gap:12px;align-items:center}
  .vname{font-weight:800}.vmeta{color:#a6acc3;font-size:12px}.vrow-actions{display:flex;gap:8px;justify-content:flex-end}
  .vcollapse{background:#222842;border:0;color:#e9ebf2;border-radius:10px;padding:6px 10px;cursor:pointer}
  .vrow-body{margin-top:10px;display:none}.vrow[aria-expanded="true"] .vrow-body{display:block}
  .vtable-wrap{overflow:auto;max-height:40vh;border:1px solid #23263a;border-radius:12px;padding:8px}
  .vtable{width:100%;border-collapse:separate;border-spacing:0 6px;font-size:14px}.vtable th{text-align:left;color:#a6acc3;font-weight:600}.vtable td{vertical-align:top}
  .hint{color:#a6acc3;font-size:12px}.warn{color:#f39c9c;font-size:12px}

  /* Particles host sits behind everything */
  #particles { position: fixed; inset: 0; z-index: 1; pointer-events: none; }
</style>

<!-- Argon2 runtime (worker + config). The worker loads argon2.min.js + argon2.wasm locally -->
<script defer src="argon2.config.js"></script>
<script defer src="argon2.worker.js"></script>
</head>
<body>

<!-- Particles toggle + host -->
<button id="particlesToggle" class="particles-toggle" type="button" aria-pressed="false">Particles: Off</button>
<div id="particles" aria-hidden="true"></div>

<!-- Help trigger -->
<button id="helpBtn" class="help-btn" type="button" aria-haspopup="dialog" aria-controls="helpModal">Help</button>

<!-- Help / Tutorial modal -->
<div id="helpModal" class="help-overlay" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="helpTitle">
  <div class="help-card" role="document">
    <div class="help-head">
      <div id="helpTitle" class="help-title">Blackout — Quick Tutorial</div>
      <button id="helpClose" class="hbtn" type="button" aria-label="Close tutorial">Close</button>
    </div>
    <div class="help-body" id="helpSlides">
      <section class="help-slide active">
        <p><strong>What is Blackout?</strong> It wraps any file inside a PNG container and restores it later using your passphrase.</p>
        <ul>
          <li>Works fully offline (PWA).</li>
          <li>Uses AES-GCM with PBKDF2 or Argon2id KDF.</li>
          <li>Optional cover image to make the PNG look like a normal picture.</li>
        </ul>
      </section>

      <section class="help-slide">
        <p><strong>Encrypt → PNG</strong></p>
        <ul>
          <li>Drop a file or choose it.</li>
          <li>Enter a strong passphrase. Pick a KDF (PBKDF2=compatible, Argon2id=stronger on desktops).</li>
          <li>Optional: set “Stored filename” (restored on decrypt). If omitted, we keep the original name privately.</li>
          <li>Optional: choose a cover image (output will visually match it).</li>
          <li>Click <em>Encrypt</em> — we download the PNG.</li>
        </ul>
      </section>

      <section class="help-slide">
        <p><strong>Decrypt ← PNG</strong></p>
        <ul>
          <li>Drop the PNG container and enter the same passphrase.</li>
          <li>We recover the original file and name.</li>
        </ul>
      </section>

      <section class="help-slide">
        <p><strong>Vaults (local, encrypted logs)</strong></p>
        <ul>
          <li>Create a vault and unlock it with your App Lock passcode.</li>
          <li>Set one vault as <em>Active</em> to auto-log your future encrypts (name, size, KDF, notes).</li>
          <li>All vault content is encrypted at rest in your browser storage.</li>
        </ul>
      </section>

      <section class="help-slide">
        <p><strong>Tips & Limits</strong></p>
        <ul>
          <li>Argon2id presets are memory-hard; on mobile they may be slower or limited.</li>
          <li>Current build caps input file size at 100&nbsp;MB (tunable in code).</li>
          <li>Everything runs locally — nothing is uploaded.</li>
        </ul>
      </section>
    </div>

    <div class="help-actions">
      <div class="left">
        <button id="helpBack" class="hbtn" type="button">Back</button>
      </div>
      <div class="right">
        <button id="helpSkip" class="hbtn" type="button">Skip</button>
        <button id="helpNext" class="hbtn primary" type="button">Next</button>
      </div>
    </div>
    <div class="dots" id="helpDots" aria-hidden="true"></div>
  </div>
</div>

<div class="wrap">
  <h1>Blackout v2</h1>
  <p class="sub">Encrypt any file into a PNG (optional cover image) and decrypt it back — fully offline.</p>

  <div class="grid">
    <!-- ENCRYPT -->
    <section class="card" id="enc-card">
      <h3>Encrypt → PNG</h3>

      <label class="drop" id="enc-drop" for="enc-file">
        <div><strong id="enc-drop-label">Drop file here</strong><br/>or choose…</div>
      </label>
      <input id="enc-file" type="file" class="sr-only" />

      <div class="row3">
        <div>
          <label>Passphrase</label>
          <input id="enc-pass" type="password" placeholder="Strong passphrase" autocomplete="new-password">
        </div>
        <div>
          <label>KDF</label>
          <select id="kdf-select">
            <option value="pbkdf2_std" selected>PBKDF2 — Standard</option>
            <option value="pbkdf2_strong">PBKDF2 — Strong</option>
            <optgroup label="Argon2id (memory-hard)">
              <option value="argon2id_interactive">Argon2id — Interactive</option>
              <option value="argon2id_balanced">Argon2id — Balanced</option>
              <option value="argon2id_high">Argon2id — High</option>
            </optgroup>
          </select>
          <small class="hint" id="kdfHint">PBKDF2 is most compatible; Argon2id is stronger on desktops.</small>
        </div>
        <div>
          <label>Output PNG name</label>
          <input id="enc-png-name" type="text" placeholder="e.g., blackout_1234">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Stored filename (restored on decrypt)</label>
          <input id="enc-stored-name" type="text" placeholder="e.g., secret.pdf">
        </div>

        <div>
          <label class="form-label">Cover Image (Optional)</label>
          <label id="coverPicker" class="cover-picker" for="coverImage" role="button" aria-label="Choose cover image">
            <span class="upload-text">Choose cover image</span>
          </label>
          <input id="coverImage" type="file" accept="image/*" class="sr-only">
          <small class="hint">If set, the output looks like this image (still saved as PNG).</small>
        </div>
      </div>

      <div class="actions">
        <button id="btn-enc">Encrypt</button>
        <button id="btn-clear-enc" class="secondary">Clear</button>
      </div>
      <div id="enc-log" class="log" style="margin-top:10px">Ready.</div>
    </section>

    <!-- DECRYPT -->
    <section class="card" id="dec-card">
      <h3>Decrypt ← PNG</h3>

      <label class="drop" id="dec-drop" for="dec-file">
        <div><strong id="dec-drop-label">Drop PNG here</strong><br/>or choose…</div>
      </label>
      <input id="dec-file" type="file" accept="image/png" class="sr-only" />

      <label style="margin-top:10px">Passphrase</label>
      <input id="dec-pass" type="password" placeholder="Your passphrase" autocomplete="current-password">

      <div class="actions">
        <button id="btn-dec">Decrypt</button>
        <button id="btn-clear-dec" class="secondary">Clear</button>
      </div>
      <div id="dec-log" class="log" style="margin-top:10px">Ready.</div>
    </section>
  </div>
</div>

<script>
/* ---------- small helpers ---------- */
const $ = (id)=>document.getElementById(id);
const TE = new TextEncoder(), TD = new TextDecoder();
function log(el,msg,cls=''){ el.className='log '+(cls||''); el.textContent=msg; }
function concatBytes(...arrs){ let len=arrs.reduce((a,b)=>a+b.length,0),out=new Uint8Array(len),off=0; for(const a of arrs){ out.set(a,off); off+=a.length; } return out; }
function be64(n){ const out=new Uint8Array(8); for(let i=7;i>=0;i--){ out[i]=Number(n&0xffn); n>>=8n; } return out; }
function readBE64(u8,off){ let n=0n; for(let i=0;i<8;i++) n=(n<<8n)|BigInt(u8[off+i]); return n; }
function randomBytes(n){ const out=new Uint8Array(n); let o=0; while(o<n){ const len=Math.min(n-o,65536); const chunk=new Uint8Array(len); crypto.getRandomValues(chunk); out.set(chunk,o); o+=len; } return out; }
function safeFilename(name){ name=(name||'').normalize?name.normalize('NFC'):(name||''); name=name.replace(/[\\/:*?"<>|]/g,'_').replace(/[\u0000-\u001F\u007F-\u009F]/g,'_').trim(); if(!name) name='file'; if(name.length>200) name=name.slice(0,200); return name; }
function splitNameExt(name){ const i=(name||'').lastIndexOf('.'); return (i>0&&i<name.length-1)?{base:name.slice(0,i),ext:name.slice(i)}:{base:name||'file',ext:''}; }
function sanitizeExt(ext){ return (/^\.[A-Za-z0-9]{1,10}$/).test(ext||'') ? ext : ''; }

/* ---------- Argon2 worker bridge & guardrails ---------- */
let ARGON_READY=false;
let argonWorker=null;
window.addEventListener('argon2-ready', ()=>{ ARGON_READY=true; });
function isMobile(){ return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent); }
function deviceMemGiB(){ return (navigator.deviceMemory||0); }

async function argon2Derive(passUtf8, salt, mode){
  if (!ARGON_READY) throw new Error('Argon2 engine not available');
  return new Promise((resolve, reject) => {
    const id = Math.random().toString(36).slice(2);
    const onMsg = (e) => {
      const d = e.data || {};
      if (d.id !== id) return;
      argonWorker.removeEventListener('message', onMsg);
      if (d.ok) resolve(new Uint8Array(d.key));
      else reject(new Error(d.error || 'Argon2 failed'));
    };
    argonWorker.addEventListener('message', onMsg);

    // Keep original salt on main thread; transfer only pass bytes
    const passBuf  = passUtf8 instanceof Uint8Array ? passUtf8 : new Uint8Array(passUtf8);
    const saltCopy = (salt instanceof Uint8Array ? salt : new Uint8Array(salt)).slice();

    argonWorker.postMessage(
      { type:'derive', id, pass: passBuf, salt: saltCopy, mode, caps:{ mobile:isMobile(), memGiB:deviceMemGiB() } },
      [passBuf.buffer]
    );
  });
}

/* ---------- KDF selection (PBKDF2 + Argon2id) ---------- */
async function kdf_pbkdf2(pass,salt,iters){
  const keyMaterial = await crypto.subtle.importKey('raw', TE.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:iters}, keyMaterial, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']);
}
async function deriveAesKey(pass,salt,mode){
  if(mode.startsWith('argon2id')){
    const raw = await argon2Derive(TE.encode(pass), salt, mode);
    return crypto.subtle.importKey('raw', raw, {name:'AES-GCM'}, false, ['encrypt','decrypt']);
  }
  const isMob = isMobile();
  const iters = mode==='pbkdf2_strong' ? (isMob?400000:1000000) : 250000;
  return kdf_pbkdf2(pass, salt, iters);
}

/* ---------- PNG helpers ---------- */
async function imageFileToPngBytes(file){
  if (file && file.type === 'image/png') return new Uint8Array(await file.arrayBuffer());
  const bmp=('createImageBitmap' in window)? await createImageBitmap(file) : await new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=rej; img.src=URL.createObjectURL(file); });
  const w=bmp.width,h=bmp.height;
  let canvas; if(typeof OffscreenCanvas!=='undefined'){ canvas=new OffscreenCanvas(w,h); } else { canvas=Object.assign(document.createElement('canvas'),{width:w,height:h}); }
  const ctx=canvas.getContext('2d'); ctx.drawImage(bmp,0,0);
  const blob=canvas.convertToBlob? await canvas.convertToBlob({type:'image/png'}) : await new Promise(r=>canvas.toBlob(r,'image/png'));
  return new Uint8Array(await blob.arrayBuffer());
}
async function makeBlackPNG(){
  const size=128; let canvas; if(typeof OffscreenCanvas!=='undefined'){ canvas=new OffscreenCanvas(size,size);} else { canvas=Object.assign(document.createElement('canvas'),{width:size,height:size}); }
  const ctx=canvas.getContext('2d'); ctx.fillStyle='#000'; ctx.fillRect(0,0,size,size);
  const blob=canvas.convertToBlob? await canvas.convertToBlob({type:'image/png'}) : await new Promise(r=>canvas.toBlob(r,'image/png'));
  return new Uint8Array(await blob.arrayBuffer());
}

/* ---------- container v2 (versioned) ---------- */
const KDF_CODE = {
  'pbkdf2_std':0, 'pbkdf2_strong':1,
  'argon2id_interactive':2, 'argon2id_balanced':3, 'argon2id_high':4
};
const CODE_KDF = Object.fromEntries(Object.entries(KDF_CODE).map(([k,v])=>[v,k]));

async function encryptBlob(file, pass, storedName, kdfMode, coverPngBytes){
  const MAX_BYTES = 100 * 1024 * 1024; // adjust if you want a higher cap
  if (file.size > MAX_BYTES) throw new Error('File exceeds 100 MB cap.');
  const fileBytes = new Uint8Array(await file.arrayBuffer());
  const pick = (storedName && storedName.trim()) ? storedName.trim() : (file.name || 'file.bin');
  const parts = splitNameExt(pick);
  const meta = {
    filename: safeFilename(parts.base),
    ext: sanitizeExt(parts.ext) || sanitizeExt(splitNameExt(file.name||'').ext) || '',
    mime: file.type || 'application/octet-stream',
    size: fileBytes.length
  };
  const metaJson = TE.encode(JSON.stringify(meta));
  const metaLen  = new Uint8Array(4); new DataView(metaLen.buffer).setUint32(0, metaJson.length, false);
  let plain = concatBytes(metaLen, metaJson, fileBytes);
  const block=256*1024, padLen=(block - (plain.length % block)) % block;
  if (padLen) plain = concatBytes(plain, randomBytes(padLen));

  const salt=randomBytes(16), nonce=randomBytes(12);
  const key = await deriveAesKey(pass, salt, kdfMode);
  const ct  = new Uint8Array(await crypto.subtle.encrypt({name:'AES-GCM',iv:nonce}, key, plain));

  const marker = randomBytes(16);
  const header = concatBytes(marker, new Uint8Array([1]), new Uint8Array([KDF_CODE[kdfMode]??0]), salt, nonce);
  const body   = concatBytes(header, ct);
  const len    = be64(BigInt(body.length));
  const trailer= concatBytes(len, marker);
  const png    = (coverPngBytes && coverPngBytes.length) ? coverPngBytes : await makeBlackPNG();
  const out    = concatBytes(png, body, trailer);
  return new Blob([out], {type:'image/png'});
}

async function decryptPNG(pngFile, pass){
  const bytes=new Uint8Array(await pngFile.arrayBuffer());
  if (bytes.length<24) throw new Error('Too small');
  const len=readBE64(bytes, bytes.length-24);
  const bodyEndBig=BigInt(bytes.length-24);
  if (len<=0n || len>bodyEndBig) throw new Error('Invalid container length');
  const bodyStart=Number(bodyEndBig-len), bodyEnd=Number(bodyEndBig);
  const body=bytes.slice(bodyStart, bodyEnd);

  // Check marker match
  const markerFooter = bytes.slice(bytes.length-16);
  for(let i=0;i<16;i++){ if(body[i]!==markerFooter[i]) throw new Error('Not a Blackout container (marker).'); }

  let kdfMode='pbkdf2_std', salt, nonce, ct, version=0;
  if (body.length>=16+1+1+16+12 && body[16]===1){
    version=1;
    const kdfCode=body[17]; kdfMode=CODE_KDF[kdfCode]||'pbkdf2_std';
    salt = body.slice(18, 34);
    nonce= body.slice(34, 46);
    ct   = body.slice(46);
  } else { // v1 fallback
    salt = body.slice(16, 32);
    nonce= body.slice(32, 44);
    ct   = body.slice(44);
  }

  async function tryDecrypt(mode){
    const key = await deriveAesKey(pass, salt, mode);
    const plain = new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:nonce}, key, ct));
    const metaLen=new DataView(plain.buffer, plain.byteOffset, plain.byteLength).getUint32(0, false);
    const meta = JSON.parse(TD.decode(plain.slice(4, 4+metaLen)));
    const fileBytes = plain.slice(4+metaLen, 4+metaLen + (meta.size||0));
    let outName='restored.bin';
    if (meta && typeof meta==='object'){
      if (meta.filename && meta.ext!==undefined){ outName = safeFilename(meta.filename) + (sanitizeExt(meta.ext)||''); }
      else if (meta.filename){ outName = safeFilename(meta.filename); }
    }
    return { meta, fileBytes, outName, mime: meta.mime||'application/octet-stream' };
  }

  if (version===1){
    return tryDecrypt(kdfMode);
  } else {
    for (const mode of ['pbkdf2_strong','pbkdf2_std']){
      try{ return await tryDecrypt(mode); }catch(_){}
    }
    throw new Error('Wrong passphrase or unknown KDF.');
  }
}
</script>

<!-- Output name helpers -->
<script>
(function(){
  function pick(){ for(const s of arguments){ const el=document.querySelector(s); if(el) return el; } return null; }
  const outNameEl = pick('#enc-png-name','input[name="outputName"]');
  const kdfSel    = pick('#kdf-select','select[name="kdf"]');
  const coverEl   = document.getElementById('coverImage');

  function genOutputName(ext='png'){ const a=Math.random().toString(36).slice(2,8); const b=Math.random().toString(36).slice(2,6); return `blackout_${a}_${b}.${ext}`; }
  function normalizeOutName(raw,ext='png'){ let s=(raw||'').trim().replace(/[/\\:*?"<>|]/g,'-'); if(!s) return genOutputName(ext); s=s.replace(/^[.\s]+/,''); const wanted=ext.toLowerCase(); if (s.toLowerCase().endsWith('.blackout')) return s; if(!s.toLowerCase().endsWith('.'+wanted)) s+='.'+wanted; return s; }

  window.computeSafeOutputName = function(userProvidedName,forceExt){ const ext=(forceExt||'png').toLowerCase(); if(!userProvidedName) return genOutputName(ext); return normalizeOutName(userProvidedName,ext); };
  window.getSelectedKdfLabel = function(){ if(kdfSel){ const opt=kdfSel.options[kdfSel.selectedIndex]; return (opt&&(opt.textContent||opt.innerText||'')).trim()||'PBKDF2 — Standard'; } return 'PBKDF2 — Standard'; };
  window.isCoverUsed = function(){ try{ return !!(coverEl && coverEl.files && coverEl.files.length); } catch { return false; } };
})();
</script>

<!-- UI wiring + drag/drop + Argon2 worker boot -->
<script>
(function(){
  const encFile=$('enc-file'), encPass=$('enc-pass'), encLog=$('enc-log'), btnEnc=$('btn-enc'), btnClearEnc=$('btn-clear-enc');
  const decFile=$('dec-file'), decPass=$('dec-pass'), decLog=$('dec-log'), btnDec=$('btn-dec'), btnClearDec=$('btn-clear-dec');
  const encStoredName=$('enc-stored-name'), encPNGName=$('enc-png-name'), kdfSelect=$('kdf-select');
  const encCover=document.getElementById('coverImage'); const encDrop=$('enc-drop'), decDrop=$('dec-drop'); const encDropLabel=$('enc-drop-label'), decDropLabel=$('dec-drop-label');
  const kdfHint = document.getElementById('kdfHint');

  // Boot Argon2 worker (if available)
  try {
    argonWorker = new Worker('argon2.worker.js');
    argonWorker.addEventListener('message', (e) => {
      if (e && e.data && e.data.type === 'ready') {
        ARGON_READY = true;
      }
    });
    argonWorker.postMessage({ type: 'ping' });
  } catch (e) {
    console.debug('Argon2 worker unavailable', e);
  }

  // Prevent nav on drop
  ['dragover','drop'].forEach(t=>{ addEventListener(t,e=>e.preventDefault(),true); document.addEventListener(t,e=>e.preventDefault(),true); });

  function wireDrop(zone,input,labelEl,acceptFn){
    zone.addEventListener('dragover',e=>{ e.preventDefault(); zone.classList.add('active'); });
    zone.addEventListener('dragleave',()=>zone.classList.remove('active'));
    zone.addEventListener('drop',e=>{
      e.preventDefault(); zone.classList.remove('active');
      const files=Array.from(e.dataTransfer.files||[]); const picked=acceptFn?files.find(acceptFn):files[0]; if(!picked) return;
      let dt; try{ dt=new DataTransfer(); }catch{ dt=new ClipboardEvent('').clipboardData||null; }
      if(dt){ dt.items.add(picked); input.files=dt.files; }
      input.dispatchEvent(new Event('change',{bubbles:true})); if(labelEl) labelEl.textContent=picked.name;
    });
  }
  wireDrop(encDrop, encFile, encDropLabel, ()=>true);
  wireDrop(decDrop, decFile, decDropLabel, f=>/image\/png$/i.test(f.type));

  encFile.addEventListener('change',()=>{ if(encFile.files.length){ encDropLabel.textContent=encFile.files[0].name; log(encLog,`Picked: ${encFile.files[0].name}`);} });
  decFile.addEventListener('change',()=>{ if(decFile.files.length){ decDropLabel.textContent=decFile.files[0].name; log(decLog,`Picked PNG: ${decFile.files[0].name}`);} });

  btnClearEnc.onclick=()=>{ encFile.value=''; encPass.value=''; encStoredName.value=''; encPNGName.value=''; encCover.value=''; log(encLog,'Cleared.'); encDropLabel.textContent='Drop file here'; };
  btnClearDec.onclick=()=>{ decFile.value=''; decPass.value=''; log(decLog,'Cleared.'); decDropLabel.textContent='Drop PNG here'; };

  // Warn if Argon2 selected on mobile
  kdfSelect.addEventListener('change', ()=>{
    const val=kdfSelect.value, mob=/Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    if(val.startsWith('argon2id') && mob) kdfHint.textContent='Argon2id may be heavy on mobile; consider PBKDF2 or Argon2id — Interactive.';
    else kdfHint.textContent='PBKDF2 is most compatible; Argon2id is stronger on desktops.';
  });

  btnEnc.onclick = async () => {
    const f    = encFile.files[0];
    const p    = encPass.value;
    const mode = kdfSelect.value;

    if (!f) return log(encLog, 'Pick a file.', 'err');
    if (!p || p.length < 6) return log(encLog, 'Use a stronger passphrase (6+ characters).', 'err');

    if (mode.startsWith('argon2id') && !ARGON_READY) {
      return log(encLog, 'Argon2 engine missing. Ensure argon2.min.js (bundled) is in the project root, then reload.', 'err');
    }

    btnEnc.disabled = true;
    log(encLog, 'Encrypting…');

    try {
      let coverBytes = null;
      if (encCover && encCover.files && encCover.files[0]) {
        log(encLog, 'Encrypting…\nPreparing cover image…');
        coverBytes = await imageFileToPngBytes(encCover.files[0]);
      }

      const blob    = await encryptBlob(f, p, encStoredName.value, mode, coverBytes);
      const outName = window.computeSafeOutputName(($('enc-png-name')?.value || '').trim(), 'png');

      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = outName;
      a.click();
      setTimeout(() => URL.revokeObjectURL(a.href), 8000);
      log(encLog, 'Done → ' + outName, 'ok');

      // Log to active vault
      const kdfLabel = window.getSelectedKdfLabel();
      const notes    = window.isCoverUsed() ? 'Cover used' : '';
      window.blackoutLogEncryption?.({
        originalName: f?.name || '(unknown)',
        outputName: outName,
        size: f?.size || 0,
        kdf: kdfLabel,
        notes
      });

      // reset cover picker label after success
      if (encCover) {
        encCover.value = '';
        const txt = document.querySelector('#coverPicker .upload-text');
        if (txt) txt.textContent = 'Choose cover image';
      }
    } catch (e) {
      log(encLog, e?.message || String(e), 'err');
    } finally {
      btnEnc.disabled = false;
    }
  };

  btnDec.onclick = async ()=>{
    const f=decFile.files[0], p=decPass.value;
    if(!f) return log(decLog,'Pick a PNG.','err');
    if(!p) return log(decLog,'Enter passphrase.','err');
    btnDec.disabled=true; log(decLog,'Decrypting…');
    try{
      const {meta,fileBytes,outName,mime} = await decryptPNG(f,p);
      const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([fileBytes],{type:mime})); a.download=outName; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href),8000);
      log(decLog,`Recovered “${a.download}” (${meta.size} bytes).`,'ok');
    }catch(e){ log(decLog, e?.message || String(e), 'err'); }
    finally{ btnDec.disabled=false; }
  };
})();
</script>

<!-- Cover picker label/drag -->
<script>
const coverInput=document.getElementById('coverImage'); const coverPicker=document.getElementById('coverPicker');
if(coverInput && coverPicker){
  const coverText=coverPicker.querySelector('.upload-text');
  coverInput.addEventListener('change',()=>{ const f=coverInput.files&&coverInput.files[0]; coverText.textContent=f?f.name:'Choose cover image'; });
  ['dragover','drop'].forEach(ev=>coverPicker.addEventListener(ev,e=>e.preventDefault()));
  coverPicker.addEventListener('dragover',()=>coverPicker.classList.add('active'));
  coverPicker.addEventListener('dragleave',()=>coverPicker.classList.remove('active'));
  coverPicker.addEventListener('drop',e=>{
    coverPicker.classList.remove('active');
    const files=e.dataTransfer&&e.dataTransfer.files; const f=files&&files[0]; if(!f) return;
    let dt; try{ dt=new DataTransfer(); }catch{ dt=new ClipboardEvent('').clipboardData||null; }
    if(dt){ dt.items.add(f); coverInput.files=dt.files; } else { coverText.textContent=f.name; return; }
    coverInput.dispatchEvent(new Event('change',{bubbles:true}));
  });
}
</script>

<!-- Vaults (unchanged from your latest) -->
<section class="vaults-card" id="vaultsCard" aria-label="Vaults">
  <div class="vaults-head">
    <div class="vaults-title">Vaults</div>
    <div class="vaults-actions">
      <input id="newVaultName" class="vinput" placeholder="New vault name (e.g., Personal)" />
      <button id="createVaultBtn" class="vbtn primary" title="Create empty vault; unlock with App Lock passcode">Create new</button>
    </div>
  </div>

  <div class="vaults-body">
    <div id="vaultsNotice" class="hint">No vault unlocked. Create one or unlock an existing vault to start auto-logging encrypts.</div>
    <div id="vaultsList" class="vlist"></div>
  </div>
</section>

<script>
/* === Vaults logic (unchanged) === */
(function(){
  const IDX_KEY='blackout.vaults.index.v1', VAULT_PREFIX='blackout.vault.v1::', ACTIVE_KEY='blackout.activeVaultId';
  const enc=new TextEncoder(), dec=new TextDecoder(); const $=s=>document.querySelector(s);
  const listEl=$('#vaultsList'), noticeEl=$('#vaultsNotice'); const unlocked=new Map();
  function b64e(buf){ return btoa(String.fromCharCode(...new Uint8Array(buf))); } function b64d(s){ return Uint8Array.from(atob(s),c=>c.charCodeAt(0)); }
  function now(){ return Date.now(); } function fmt(n){ const u=['B','KB','MB','GB']; let i=0; while(n>=1024&&i<u.length-1){n/=1024;i++;} return (n<10&&i?n.toFixed(1):Math.round(n))+' '+u[i]; }
  function readIndex(){ try{ return JSON.parse(localStorage.getItem(IDX_KEY)||'[]'); }catch{ return []; } }
  function writeIndex(arr){ localStorage.setItem(IDX_KEY, JSON.stringify(arr)); }
  function readVaultRaw(id){ try{ const s=localStorage.getItem(VAULT_PREFIX+id); return s?JSON.parse(s):null; }catch{ return null; } }
  function writeVaultRaw(id,obj){ localStorage.setItem(VAULT_PREFIX+id, JSON.stringify(obj)); }
  async function deriveKey(pass,salt,iters=150000){ const base=await crypto.subtle.importKey('raw',enc.encode(pass),{name:'PBKDF2'},false,['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:iters,hash:'SHA-256'}, base,{name:'AES-GCM',length:256},false,['encrypt','decrypt']); }
  async function encryptArr(key,arr){ const iv=crypto.getRandomValues(new Uint8Array(12)); const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},key,enc.encode(JSON.stringify(arr))); return {iv:b64e(iv),data:b64e(ct),ts:now()}; }
  async function decryptArr(key,ivB64,dataB64){ const iv=b64d(ivB64), data=b64d(dataB64); const pt=await crypto.subtle.decrypt({name:'AES-GCM',iv},key,data); return JSON.parse(dec.decode(pt)); }
  function uid(){ return Math.random().toString(36).slice(2)+Date.now().toString(36); }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function tableHtml(id,arr){ const rows=[...arr].sort((a,b)=>(b.when||0)-(a.when||0)); const tr=rows.map(r=>`<tr><td>${new Date(r.when||Date.now()).toLocaleString()}</td><td>${escapeHtml(r.originalName||'-')}</td><td style="text-align:right">${fmt(r.size||0)}</td><td>${escapeHtml(r.outputName||'-')}</td><td>${escapeHtml(r.kdf||'-')}</td><td>${escapeHtml(r.notes||'')}</td></tr>`).join(''); return `<div style="display:flex;gap:8px;justify-content:flex-end;margin:6px 0 8px"><button class="vbtn" data-act="make-active" title="Use this as default target for auto-log">Set Active</button><button class="vbtn" data-act="add-test">Add test</button></div><div class="vtable-wrap"><table class="vtable"><thead><tr><th>When</th><th>Original name</th><th style="text-align:right">Size</th><th>Output</th><th>KDF</th><th>Notes</th></tr></thead><tbody>${tr||''}</tbody></table></div>${rows.length?'':`<div class="hint" style="margin-top:6px">No entries yet. Encrypt something — it will appear here if this vault is active.</div>`}`; }
  function render(){ const idx=readIndex().sort((a,b)=>(b.updated||b.created)-(a.updated||a.created)); listEl.innerHTML=''; if(!idx.length){ listEl.innerHTML=`<div class="hint">No vaults yet. Create your first vault above.</div>`; return; }
    const activeId=sessionStorage.getItem(ACTIVE_KEY); noticeEl.textContent=unlocked.size?`Active vault: ${activeId?(idx.find(v=>v.id===activeId)?.name||'Unknown'):'—'}`:'No vault unlocked. Create or unlock to start auto-logging.';
    for(const v of idx){ const row=document.createElement('div'); row.className='vrow'; row.setAttribute('data-id',v.id); row.setAttribute('aria-expanded','false'); const isUnlocked=unlocked.has(v.id); const count=v.count||0; const updated=new Date(v.updated||v.created).toLocaleString();
      row.innerHTML=`<div class="vrow-head"><div><div class="vname">${escapeHtml(v.name)}</div><div class="vmeta">Created ${new Date(v.created).toLocaleString()} • Updated ${updated} • ${count} item${count===1?'':'s'}</div></div><div class="vmeta ${isUnlocked?'':'warn'}" style="justify-self:end">${isUnlocked?'Unlocked':'Locked'}</div><div class="vrow-actions">${isUnlocked?`<button class="vbtn" data-act="lock">Lock</button><button class="vbtn" data-act="export">Export CSV</button><button class="vbtn" data-act="clear">Clear</button>`:`<input type="password" class="vinput" data-act="pass" placeholder="App Lock passcode" style="max-width:220px"><button class="vbtn primary" data-act="unlock">Unlock</button>`}<button class="vbtn" data-act="rename">Rename</button><button class="vbtn" data-act="delete">Delete</button><button class="vcollapse" data-act="toggle">${isUnlocked?'Collapse':'Expand'}</button></div></div><div class="vrow-body">${isUnlocked?tableHtml(v.id, unlocked.get(v.id).data):`<div class="hint">Unlock to view entries.</div>`}</div>`;
      row.addEventListener('click', async (e)=>{ const act=e.target?.getAttribute?.('data-act'); if(!act) return; const id=v.id;
        if(act==='toggle'){ const ex=row.getAttribute('aria-expanded')==='true'; row.setAttribute('aria-expanded',String(!ex)); if(!ex&&unlocked.has(id)) row.querySelector('.vrow-body').innerHTML=tableHtml(id,unlocked.get(id).data); }
        if(act==='unlock'){ const pass=row.querySelector('[data-act="pass"]').value||''; const raw=readVaultRaw(id); if(!raw||!raw.salt){ alert('Vault is missing or corrupt.'); return; } try{ const base=await crypto.subtle.importKey('raw',enc.encode(pass),{name:'PBKDF2'},false,['deriveKey']); const key=await crypto.subtle.deriveKey({name:'PBKDF2',salt:Uint8Array.from(atob(raw.salt),c=>c.charCodeAt(0)),iterations:150000,hash:'SHA-256'}, base,{name:'AES-GCM',length:256},false,['encrypt','decrypt']); const data=raw.iv&&raw.data? await (async()=>{ const iv=Uint8Array.from(atob(raw.iv),c=>c.charCodeAt(0)); const ct=Uint8Array.from(atob(raw.data),c=>c.charCodeAt(0)); const pt=await crypto.subtle.decrypt({name:'AES-GCM',iv},key,ct); return JSON.parse(dec.decode(new Uint8Array(pt))); })():[]; unlocked.set(id,{key,data}); sessionStorage.setItem(ACTIVE_KEY,id); row.setAttribute('aria-expanded','true'); render(); }catch(err){ alert('Incorrect passcode or corrupt vault.'); } }
        if(act==='lock'){ unlocked.delete(id); if(sessionStorage.getItem(ACTIVE_KEY)===id) sessionStorage.removeItem(ACTIVE_KEY); render(); }
        if(act==='export'){ const d=unlocked.get(id)?.data||[]; if(!d.length){ alert('Nothing to export.'); return; } const header=['when_iso','original_name','size_bytes','output_name','kdf','notes']; const rows=d.map(r=>[new Date(r.when||Date.now()).toISOString(), r.originalName||'', r.size||0, r.outputName||'', r.kdf||'', (r.notes||'').replace(/\n/g,' ')]); const csv=[header.join(','), ...rows.map(r=>r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(','))].join('\n'); const blob=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`vault_${id}.csv`; a.click(); URL.revokeObjectURL(a.href); }
        if(act==='clear'){ if(!confirm('Clear all entries in this vault?')) return; const rec=unlocked.get(id); if(!rec) return alert('Unlock first.'); rec.data=[]; await (async()=>{ const encd=await (async()=>{ const iv=crypto.getRandomValues(new Uint8Array(12)); const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},rec.key,enc.encode(JSON.stringify(rec.data))); return {iv:btoa(String.fromCharCode(...iv)), data:btoa(String.fromCharCode(...new Uint8Array(ct))), ts:now()}; })(); const raw=readVaultRaw(id); writeVaultRaw(id,{v:1, iv:encd.iv, data:encd.data, salt:raw.salt, ts:now()}); const idx=readIndex(); const meta=idx.find(x=>x.id===id); if(meta){ meta.updated=now(); meta.count=0; writeIndex(idx); } })(); render(); }
        if(act==='delete'){ if(!confirm(`Delete vault “${v.name}”? This cannot be undone.`)) return; localStorage.removeItem(VAULT_PREFIX+id); writeIndex(readIndex().filter(x=>x.id!==id)); unlocked.delete(id); if(sessionStorage.getItem(ACTIVE_KEY)===id) sessionStorage.removeItem(ACTIVE_KEY); render(); }
        if(act==='rename'){ const name=prompt('New name:', v.name); if(!name) return; const idx=readIndex(); const meta=idx.find(x=>x.id===id); if(!meta) return; meta.name=name; meta.updated=now(); writeIndex(idx); render(); }
        if(act==='make-active'){ if(!unlocked.has(id)){ alert('Unlock this vault first.'); return; } sessionStorage.setItem(ACTIVE_KEY,id); noticeEl.textContent=`Active vault: ${v.name}`; }
        if(act==='add-test'){ const rec=unlocked.get(id); if(!rec){ alert('Unlock first.'); return; } rec.data.push({originalName:'secret.pdf', outputName:'blackout_demo.png', size:1234567, kdf:'PBKDF2 — Standard', notes:'Cover used', when:now()}); const encd=await (async()=>{ const iv=crypto.getRandomValues(new Uint8Array(12)); const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},rec.key,enc.encode(JSON.stringify(rec.data))); return {iv:btoa(String.fromCharCode(...iv)), data:btoa(String.fromCharCode(...new Uint8Array(ct))), ts:now()}; })(); const raw=readVaultRaw(id); writeVaultRaw(id,{v:1, iv:encd.iv, data:encd.data, salt:raw.salt, ts:now()}); const idx=readIndex(); const meta=idx.find(x=>x.id===id); if(meta){ meta.updated=now(); meta.count=rec.data.length; writeIndex(idx);} render(); }
      });
      listEl.appendChild(row);
    }
  }
  document.getElementById('createVaultBtn').addEventListener('click', async ()=>{
    const name=(document.getElementById('newVaultName').value || 'Vault '+new Date().toLocaleDateString()).trim(); if(!name) return;
    const pass=prompt('Enter your App Lock passcode to create this vault:')||''; const salt=crypto.getRandomValues(new Uint8Array(16));
    const base=await crypto.subtle.importKey('raw',new TextEncoder().encode(pass),{name:'PBKDF2'},false,['deriveKey']);
    const key=await crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:150000,hash:'SHA-256'}, base,{name:'AES-GCM',length:256},false,['encrypt','decrypt']);
    const id=Math.random().toString(36).slice(2)+Date.now().toString(36); const created=now();
    const iv=crypto.getRandomValues(new Uint8Array(12)); const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},key,new TextEncoder().encode(JSON.stringify([])));
    writeVaultRaw(id,{v:1, iv:btoa(String.fromCharCode(...iv)), data:btoa(String.fromCharCode(...new Uint8Array(ct))), salt:btoa(String.fromCharCode(...salt)), ts:created});
    const idx=readIndex(); idx.push({id,name,created,updated:created,count:0}); writeIndex(idx);
    unlocked.set(id,{key,data:[]}); sessionStorage.setItem(ACTIVE_KEY,id);
    document.getElementById('newVaultName').value=''; render();
  });
  window.blackoutLogEncryption = async function(entry){
    try{
      const active=sessionStorage.getItem(ACTIVE_KEY);
      if(!active || !unlocked.has(active)){ noticeEl.classList.add('warn'); noticeEl.textContent='No active vault unlocked. Unlock a vault and click “Set Active” to enable auto-logging.'; return; }
      const rec=unlocked.get(active); rec.data.push(Object.assign({when:Date.now(),notes:''},entry||{}));
      const iv=crypto.getRandomValues(new Uint8Array(12)); const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},rec.key,new TextEncoder().encode(JSON.stringify(rec.data)));
      const raw=readVaultRaw(active); writeVaultRaw(active,{v:1, iv:btoa(String.fromCharCode(...iv)), data:btoa(String.fromCharCode(...new Uint8Array(ct))), salt:raw.salt, ts:Date.now()});
      const idx=readIndex(); const meta=idx.find(x=>x.id===active); if(meta){ meta.updated=Date.now(); meta.count=rec.data.length; writeIndex(idx); }
      noticeEl.classList.remove('warn'); noticeEl.textContent='Logged to active vault.'; render();
    }catch(e){ console.error('[Vaults] log failed', e); }
  };
  render();
})();
</script>

<!-- Tutorial modal controller -->
<script>
(function(){
  const LS_KEY = 'blackout.tutorial.done.v1';
  const modal = document.getElementById('helpModal');
  const btnOpen = document.getElementById('helpBtn');
  const btnClose = document.getElementById('helpClose');
  const btnNext = document.getElementById('helpNext');
  const btnBack = document.getElementById('helpBack');
  const btnSkip = document.getElementById('helpSkip');
  const slidesWrap = document.getElementById('helpSlides');
  const dotsWrap = document.getElementById('helpDots');
  const slides = Array.from(slidesWrap.querySelectorAll('.help-slide'));
  let idx = 0;

  function renderDots(){ dotsWrap.innerHTML = slides.map((_,i)=>`<span class="dot ${i===idx?'active':''}" aria-hidden="true"></span>`).join(''); }
  function show(i){
    idx = Math.max(0, Math.min(slides.length-1, i));
    slides.forEach((s,j)=> s.classList.toggle('active', j===idx));
    btnBack.disabled = idx===0;
    btnNext.textContent = idx===slides.length-1 ? 'Done' : 'Next';
    renderDots();
  }
  function open(firstRun=false){
    modal.setAttribute('aria-hidden','false');
    modal.style.display = 'grid';
    document.body.style.overflow='hidden';
    // focus modal first, then close button
    modal.focus({ preventScroll:true });
    if(firstRun) idx = 0;
    show(idx);
    btnClose.focus({ preventScroll:true });
  }
  function close(done=false){
    modal.setAttribute('aria-hidden','true');
    modal.style.display = 'none';
    document.body.style.overflow='';
    if(done) localStorage.setItem(LS_KEY, '1');
    btnOpen.focus({preventScroll:true});
  }

  btnOpen.addEventListener('click', ()=> open(false));
  btnClose.addEventListener('click', ()=> close(false));
  btnSkip.addEventListener('click', ()=> close(true));
  btnBack.addEventListener('click', ()=> show(idx-1));
  btnNext.addEventListener('click', ()=> { if(idx===slides.length-1) close(true); else show(idx+1); });

  modal.addEventListener('keydown', (e)=>{
    if(e.key==='Escape') close(false);
    if(e.key==='ArrowRight') show(idx+1);
    if(e.key==='ArrowLeft') show(idx-1);
  });
  modal.addEventListener('click', (e)=>{ if(e.target===modal) close(false); });

  try {
    const firstRun = !localStorage.getItem(LS_KEY);
    if(firstRun) open(true);
  } catch {}

  renderDots();
})();
</script>

<!-- Particles loader: dynamic tuning + toggle + offline -->
<script>
(() => {
  const TOGGLE_ID = 'particlesToggle';
  const HOST_ID   = 'particles';
  const LS_KEY    = 'blackout.particles.enabled';
  const JS_PATH   = 'particles.min.js';
  const CFG_PATH  = 'particlesjs-config.json';

  const btn  = document.getElementById(TOGGLE_ID);
  const host = document.getElementById(HOST_ID);
  if (!btn || !host) return;

  const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
  const isMobileUA     = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const memGiB         = navigator.deviceMemory || 0;
  const dpr            = Math.max(1, Math.min(3, window.devicePixelRatio || 1));

  function getPref(){ try { return localStorage.getItem(LS_KEY) === '1'; } catch { return false; } }
  function setPref(v){ try { localStorage.setItem(LS_KEY, v ? '1' : '0'); } catch {} }

  let enabled = getPref() && !prefersReduced;
  let scriptLoaded = !!window.particlesJS;
  let starting = false;

  function applyParticlesClass(on){
  document.body.classList.toggle('particles-on', !!on);
}

  function setButton() {
    btn.textContent = 'Particles: ' + (enabled ? 'On' : 'Off');
    btn.setAttribute('aria-pressed', String(enabled));
  }

  function tuneConfig(cfg) {
    const baseCount  = cfg?.particles?.number?.value ?? 120;
    const baseArea   = cfg?.particles?.number?.density?.value_area ?? 800;
    const baseSpeed  = cfg?.particles?.move?.speed ?? 1;
    const baseSize   = cfg?.particles?.size?.value ?? 3;

    const area = Math.max(1, window.innerWidth * window.innerHeight);
    const areaFactor = Math.sqrt(area / (1920 * 1080));
    const memTier = memGiB >= 12 ? 3 : memGiB >= 8 ? 2 : memGiB >= 4 ? 1 : 0;

    const isMobile = isMobileUA || area < 750 * 900;
    const maxCount = isMobile ? 100 : [140, 180, 220, 260][memTier];
    const maxSpeed = isMobile ? 1.0 : 2.2;
    const maxSize  = isMobile ? 4.0 : 6.0;

    const densityBased = Math.round((area / Math.max(20000, baseArea * 1.2)) / (dpr * 0.9));
    let tunedCount = Math.min(maxCount, Math.max(25, Math.max(densityBased, Math.min(baseCount, maxCount))));

    let tunedSpeed = Math.min(maxSpeed, baseSpeed * (isMobile ? 0.5 : 0.9) * (0.85 + 0.25 * areaFactor));
    let tunedSize  = Math.min(maxSize,  baseSize  * (isMobile ? 0.6 : 0.9));

    cfg.particles ??= {};
    cfg.particles.number ??= {};
    cfg.particles.number.value = tunedCount;
    (cfg.particles.number.density ??= {}).enable = true;
    (cfg.particles.move ??= {}).enable = true;
    cfg.particles.move.speed = tunedSpeed;
    (cfg.particles.size ??= {}).value = tunedSize;

    cfg.interactivity ??= {};
    cfg.interactivity.events ??= {};
    if (isMobile) {
      cfg.interactivity.events.onhover = { enable: false };
      cfg.interactivity.events.onclick = { enable: false };
    }

    if (typeof cfg.particles.opacity?.value === 'number') {
      cfg.particles.opacity.value = Math.min(cfg.particles.opacity.value, 0.45);
    }
    return cfg;
  }

  function destroyParticles() {
    try {
      if (window.pJSDom && window.pJSDom.length) {
        window.pJSDom.forEach(p => p?.pJS?.fn?.vendors?.destroypJS?.());
        window.pJSDom.length = 0;
      }
      host.querySelectorAll('canvas').forEach(c => c.remove());
    } catch {}
  }

  async function startParticles() {
    if (starting || prefersReduced) return;
    starting = true;

    try {
      if (!scriptLoaded) {
        await new Promise((res, rej) => {
          const s = document.createElement('script');
          s.src = JS_PATH; s.async = true;
          s.onload = () => { scriptLoaded = true; res(); };
          s.onerror = () => rej(new Error('Failed to load particles.min.js'));
          document.head.appendChild(s);
        });
      }

      const resp = await fetch(CFG_PATH, { cache: 'force-cache' });
      const userCfg = await resp.json();
      const tuned   = tuneConfig(userCfg);

      destroyParticles();
      window.particlesJS(HOST_ID, tuned);
      applyParticlesClass(true);
    } catch (e) {
      console.debug('[particles] init failed:', e);
      enabled = false; setPref(false); setButton();
    } finally {
      starting = false;
    }
  }

  function stopParticles() {
    destroyParticles();
    applyParticlesClass(false);
  }

  btn.addEventListener('click', () => {
    enabled = !enabled;
    setPref(enabled);
    setButton();
    applyParticlesClass(enabled);
    enabled ? startParticles() : stopParticles();
  });

  setButton();
  applyParticlesClass(enabled);
  if (enabled) startParticles();

  // Retune on resize/orientation
  let t; addEventListener('resize', () => { if (!enabled) return; clearTimeout(t); t=setTimeout(startParticles,250); });
})();
</script>

</body>
</html>
